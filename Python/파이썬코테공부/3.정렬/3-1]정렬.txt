* 정렬 종류

버블 (n^2) : 데이터 인접요소끼리 비교하고, swap 연산을 수행하여 정렬
선택 (n^2) : 대상에서 최대나 최소 데이터를 찾아가 선택을 반복하면서 정렬
삽입 (n^2) : 대상을 선택해 정렬된 영역에서 선택 데이터의 적절한 위치를 찾아 삽입
퀵 (nlogn) : 기준값(pivot)값을 선정해 해당 값을 기준으로 정렬
병합 (nlogn) : 이미 정렬된 부분 집합들을 효율적으로 병합해 전체를 정렬
기수 (kn) : 데이터의 자릿수를 바탕으로 비교해 데이터를 정렬

* 버블 정렬

다른 정렬에 비해 시간은 오래걸리지만
상대적으로 로직이 단순, 구현이 쉽다

1. 비교연산이 필요한 루프 범위 설정
2. 인접한 데이터 값을 비교
3. swap조건에 부합하면 swap 연산을 수행
4. 루프 범위가 끝날때까지 2~3 반복
5. 정렬 영역을 설정, 다음 루프를 실행할때는 이 영억을 제외
6. 비교 대상이 없을 때까지 1~5 반복
7. 특정 루프 전체 영역에서 swap이 한번도 발생하지 않으면
   뒤에 있는 데이터가 모두 정렬됐다는 뜻이므로 프로세스 종료

오름차순이라면 가장 큰 수를 앞에서 부터 비교해서 가장 뒤로 정렬하는 느낌

* 선택 정렬

코테에 자주 사용되진 않지만 알아야 한다

핵심이론 : 최대나 최소 데이터를 찾고, 남은 정렬 부분의 가장 앞에있는 데이터와 swap하는 것

1. 남은 정렬 부분에서 최솟값 또는 최소값을 찾는다
2. 남은 정렬 부분에서 가장 앞에있는 데이터와 선택된 데이터를 swap
3. 가장 앞에 있는 데이터의 위치를 변경(index++)해 남은 정렬 부분의 범위를 축소
4. 전체 데이터 크기만큼 index가 커질때까지 반복

* 삽입 정렬

이미 정렬된 데이터 범위에 정렬되지 않은 데이터를 적절한 위치에 삽입시켜 정렬

1. 현재 index에 있는 데이터 값을 선택
2. 현재 선택한 데이터가 정렬된 데이터 범위에 삽입될 위치를 탐색
3. 삽입 위치부터 index에 있는 위치까지 shift연산 수행
4. 삽입 위치에 현재 선택한 데이터를 삽입하고 index++연산을 수행
5. 전체 데이터의 크기만큼 index가 커질때까지 반복

정렬된 데이터 안에 적절한 삽입 위치를 탐색하는 부분에서는 
이진탐색등과 같은 탐색알고리즘 사용하면 시간복잡도를 줄일 수 있다

삽입할 위치 탐색은 빠를 수 있지만 데이터를 한칸씩 shift하기때문에 시간복잡도가 좋지 않다

* 퀵 정렬

기준값(pivot)을 선정해 해당 값보다 작은 데이터와 큰 데이터로 분류 반복
평균 시간복잡도 : nlogn
최악 시간복잡도 : n^2

1. 데이터를 분할하는 pivot을 설정
2. pivot을 기준으로 다음과정을 거쳐 데이터를 2개의 집합으로 분리
    2-1. start가 가리키는 데이터가 pivot이 가리키는 데이터보다 작으면 start를 오른쪽으로 한칸 이동
    2-2. end가 가리키는 데이터가 pivot이 가리키는 데이터보다 크면 end를 왼쪽으로 한칸 이동
    2-3. start가 가리키는 데이터가 pivot이 가리키는 데이터보다 크고, end가 가리키는 데이터가
         pivot이 가리키는 데이터보다 작으면 start, end가 가리키는 데이터를 swap하고
         start는 오른쪽, end는 왼쪽으로 한칸씩 이동
    2-4. start와 end가 만날때까지 2-1~2-3을 반복
    2-5. start와 end가 만나면 만난 지점에서 가리키는 데이터와 pivot이 가리키는 데이터를
         비교하여 pivot이 가리키는 데이터가 크면 만난 지점의 오른쪽에, 작으면 만난 지점의 왼쪽에
         pivot이 가리키는 데이터를 삽입
3. 분리 집합에서 각각 다시 pivot을 선정
4. 분리 집합이 1개 이하가 될 때까지 1~3 반복

- 재귀함수의 형태로 구현해볼 것

*** 병합 정렬

분할 정복 방식을 사용, 데이터를 분할하고 분할한 집합을 정렬하며 합침
안정정, 시간복잡도 좋음 nlogn

- 두개 그룹을 병합하는 과정 (투 포인터 개념)

왼쪽 그룹의 포인터와 오른쪽 그룹의 포인터의 값을 비교하여
작은 값을 결과 배열에 추가하고
포인터를 오른쪽으로 한 칸 이동

한쪽 그룹의 데이터를 모두 추가하면 나머지 그룹엔 그대로 배열에 추가

* 기수 정렬

값을 비교하지 않는 특이한 정렬
값을 놓고 비교할 자릿수를 정한 다음 자릿수만 비교
시간 복잡도가 가장 짧다, 정렬해야 하는 데이터의 개수가 너무 많을 때 사용하면 좋다
시간 복잡도 : kn (k:데이터의 자릿수)
ex) n = 1,000,000, k = 9,999  =>  kn = 4,000,000

10개의 큐(버켓?)를 이용 - 한 자리에 올 수 있는 수는 0~9
각 큐는 값의 자릿수를 대표함

ex) 16 80 16 77 03 24 88 23

|   |   |   |23 |   |   |   |   |88 |   |
|80 |   |   |03 |24 |   |16 |77 |18 |   |         
| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |

일의 자릿수 기준으로 데이터 정렬
-> 80 03 23 24 16 77 18 88

|   | 18| 24|   |   |   |   |   | 88|   |
| 03| 16| 23|   |   |   |   | 77| 80|   |         
| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |

십의 자릿수 기준으로 데이터 정렬
-> 03 16 18 23 24 77 80 88
