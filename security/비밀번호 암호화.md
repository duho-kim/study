> JWT에 대해 알아보니 오히려 보안상 더 안좋은 부분이 있었다. <br>
> 그래서 비밀번호 암호화에 대해 알아보려고 한다.<br>
> 정처기 공부를 해서 알고는 있었지만 자세히 공부한 적이 없다.

## 단방향 해시 함수
![단방향해쉬함수](https://github.com/duho-kim/study/assets/155808974/02d6d5ce-586a-48b5-b41c-021e76709c99)
- 수학적 연산 또는 알고리즘에 의해 원본 데이터를 매핑시켜 완전히 다른 암호화된 데이터로 변환하는 것
- 패스워드 DB가 유출되어도 안전하다는 장점(하지만 이젠 안전하지 않음)
- 다이제스트(Digest) : 해시에 의해 암호화된 데이터
- 단방향 해시 함수는 다이제스트를 복호화, 즉 원본 데이터를 구할 수는 없어야 한다
- 대표 종류 : SHA, MD, HAS, WHIRLPOOL 등등 SHA-256이 가장 대표적<br>
#### 취약점
- 레인보우 테이블 : 해커들이 여러 값들을 대입해보면서 얻었던 다이제스트들을 모아놓은 리스트
                   단순한 비밀번호는 순식간에 찾아진다
- 브루트포스 : 상징성이 있는 문자나 숫자를 무차별로 대입해 다이제스트를 비교해서 알아내는 방법
- [보안 취약점 10가지](https://owasp.org/www-project-top-ten/)
  
## 키-스트레칭 (Key-Stretching)
- 브루트포스 공격(무차별 대입)을 최대한 무력화 시키기 위한 방법
- 암호화로 얻어진 다이제스트를 n번 더 암호화 시키는 것
  
## 솔트 (Salt)
- 해시 함수를 돌리기 전에 원문에 문자열을 추가하는 방법
- 사용자마다 다른 솔트를 사용한다면 비밀번호가 같아도 다이제스트가 다르다


## 올바른 방법으로 해싱
#### ※ 항상 서버에서 해싱하기
- 암호학적으로 안전한 난수 생성기를 사용해 예측 가능성을 줄여야 한다 (Cryptographically Secure Pseudo-Random Number Generator, CSPRNG)

### 언어 별 CSPRNG 목록
> 혹시 나중에 필요할수도 있으니까 <br>
PHP : [mcrypt_create_iv](https://www.php.net/manual/en/function.mcrypt-create-iv.php) / [openssl_random_pseudo_bytes](https://www.php.net/manual/en/function.openssl-random-pseudo-bytes.php) <br>
Java : [java.security.SecureRandom](https://docs.oracle.com/javase/6/docs/api/java/security/SecureRandom.html) <br>
Dot NET (C#, VB) : [System.Security.Cryptography.RNGCryptoServiceProvider](https://learn.microsoft.com/en-us/dotnet/api/system.security.cryptography.rngcryptoserviceprovider?view=net-8.0&redirectedfrom=MSDN)<br>
Ruby : [SecureRandom](https://rubydoc.info/stdlib/securerandom/1.9.3/SecureRandom) <br>
Python : [os.urandom](https://docs.python.org/3/library/os.html)<br>
Perl : [Math::Random::Secure](https://metacpan.org/release/MKANAT/Math-Random-Secure-0.06/view/lib/Math/Random/Secure.pm)<br>
C/C++ (Windows API) : [CryptGenRandom](https://en.wikipedia.org/wiki/CryptGenRandom)<br>
Any language on GNU/Linux or Unix : [/dev/random ](https://en.wikipedia.org/wiki//dev/random)<br>

### 비밀번호 저장
1. CSPRNG를 사용해 랜덤 솔트값 생성
2. 솔트값+비밀번호(or 비밀번호+솔트값) --> 해시함수(SHA-256) --> 다이제스트
3. 솔트값과 다이제스트를 DB에 저장

### 비밀번호 유효성 검사
1. 사용자의 솔트값과 다이제스트 DB에서 찾아옴
2. 입력한 비밀번호에 솔트값을 붙이고 비밀번호 해싱에 사용했던 해시함수를 사용하여 해싱
3. 입력한 비밀번호로 생성된 다이제스트와 저장된 다이제스트를 비교



